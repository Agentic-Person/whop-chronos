#!/usr/bin/env tsx
/**
 * Integration Test: Video Processing Pipeline
 * Tests the full video processing workflow from upload to RAG-ready
 */

import { config } from 'dotenv'
import { resolve } from 'path'

// Load environment variables from .env.local
config({ path: resolve(process.cwd(), '.env.local') })

import { createClient } from '@supabase/supabase-js'

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
  console.error('âŒ Missing Supabase credentials')
  process.exit(1)
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY)

const TEST_CREATOR_ID = '00000000-0000-0000-0000-000000000001'

async function testVideoPipeline() {
  console.log('ğŸ§ª Testing Video Processing Pipeline\n')

  try {
    // Test 1: Create a new video
    console.log('ğŸ“ Test 1: Creating new video...')
    const { data: video, error: createError } = await supabase
      .from('videos')
      .insert({
        creator_id: TEST_CREATOR_ID,
        title: 'Integration Test Video',
        description: 'Test video for pipeline validation',
        duration_seconds: 300,
        status: 'pending',
        file_size_bytes: 10000000
      })
      .select()
      .single()

    if (createError) throw createError
    console.log('âœ… Video created:', video.id)
    console.log('   Status:', video.status)

    // Test 2: Update video status through pipeline stages
    console.log('\nâš™ï¸  Test 2: Simulating pipeline stages...')
    const stages = ['uploading', 'transcribing', 'processing', 'embedding', 'completed']

    for (const stage of stages) {
      await new Promise(resolve => setTimeout(resolve, 500)) // Simulate processing time

      const { error: updateError } = await supabase
        .from('videos')
        .update({ status: stage })
        .eq('id', video.id)

      if (updateError) throw updateError
      console.log(`   ${getStatusEmoji(stage)} Status: ${stage}`)
    }

    // Test 3: Add transcript
    console.log('\nğŸ“„ Test 3: Adding transcript...')
    const transcript = 'This is a test transcript for integration testing. It contains multiple sentences to simulate real video content. Trading strategies include risk management and technical analysis.'

    const { error: transcriptError } = await supabase
      .from('videos')
      .update({
        transcript,
        transcript_language: 'en',
        processing_completed_at: new Date().toISOString()
      })
      .eq('id', video.id)

    if (transcriptError) throw transcriptError
    console.log('âœ… Transcript added')

    // Test 4: Create video chunks
    console.log('\nâœ‚ï¸  Test 4: Creating video chunks...')
    const chunks = [
      {
        video_id: video.id,
        chunk_index: 0,
        chunk_text: 'This is a test transcript for integration testing.',
        start_time_seconds: 0,
        end_time_seconds: 10,
        word_count: 9
      },
      {
        video_id: video.id,
        chunk_index: 1,
        chunk_text: 'It contains multiple sentences to simulate real video content.',
        start_time_seconds: 10,
        end_time_seconds: 20,
        word_count: 10
      },
      {
        video_id: video.id,
        chunk_index: 2,
        chunk_text: 'Trading strategies include risk management and technical analysis.',
        start_time_seconds: 20,
        end_time_seconds: 30,
        word_count: 9
      }
    ]

    const { error: chunksError } = await supabase
      .from('video_chunks')
      .insert(chunks)

    if (chunksError) throw chunksError
    console.log(`âœ… Created ${chunks.length} chunks`)

    // Note: In production, embeddings would be generated by OpenAI API
    console.log('â„¹ï¸  Note: Embeddings would be generated by OpenAI in production')

    // Test 5: Verify video is query-ready
    console.log('\nğŸ” Test 5: Verifying video is query-ready...')
    const { data: finalVideo, error: queryError } = await supabase
      .from('videos')
      .select(`
        id,
        title,
        status,
        transcript,
        video_chunks (
          id,
          chunk_text,
          start_time_seconds
        )
      `)
      .eq('id', video.id)
      .single()

    if (queryError) throw queryError

    console.log('âœ… Video Details:')
    console.log('   ID:', finalVideo.id)
    console.log('   Title:', finalVideo.title)
    console.log('   Status:', finalVideo.status)
    console.log('   Transcript length:', finalVideo.transcript?.length || 0, 'characters')
    console.log('   Chunks:', finalVideo.video_chunks?.length || 0)

    // Test 6: Test RAG search simulation (without actual embeddings)
    console.log('\nğŸ” Test 6: Testing chunk retrieval (RAG simulation)...')
    const { data: searchChunks, error: searchError } = await supabase
      .from('video_chunks')
      .select('id, chunk_text, start_time_seconds, end_time_seconds')
      .eq('video_id', video.id)
      .order('chunk_index')

    if (searchError) throw searchError

    console.log(`âœ… Retrieved ${searchChunks?.length || 0} chunks for RAG:`)
    searchChunks?.forEach((chunk, i) => {
      console.log(`   ${i + 1}. [${chunk.start_time_seconds}s]: ${chunk.chunk_text.substring(0, 50)}...`)
    })

    // Cleanup (optional - comment out to keep test data)
    console.log('\nğŸ§¹ Cleaning up test data...')
    const { error: cleanupError } = await supabase
      .from('videos')
      .delete()
      .eq('id', video.id)

    if (cleanupError) throw cleanupError
    console.log('âœ… Test data cleaned up')

    console.log('\nâœ… Video Pipeline Test: PASSED\n')
    console.log('ğŸ“Š Summary:')
    console.log('   âœ“ Video creation')
    console.log('   âœ“ Status progression through all stages')
    console.log('   âœ“ Transcript storage')
    console.log('   âœ“ Chunk generation')
    console.log('   âœ“ RAG-ready data structure')
    console.log('   âœ“ Data retrieval for AI chat')

  } catch (error) {
    console.error('\nâŒ Pipeline Test FAILED:', error)
    process.exit(1)
  }
}

function getStatusEmoji(status: string): string {
  const emojiMap: Record<string, string> = {
    pending: 'â³',
    uploading: 'â¬†ï¸',
    transcribing: 'ğŸ¤',
    processing: 'âš™ï¸',
    embedding: 'ğŸ§ ',
    completed: 'âœ…',
    failed: 'âŒ'
  }
  return emojiMap[status] || 'ğŸ“Œ'
}

// Run the test
testVideoPipeline()
